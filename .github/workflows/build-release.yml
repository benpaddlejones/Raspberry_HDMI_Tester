name: Build and Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (from release-config.json or override)'
        required: false
        default: ''
      force_rebuild:
        description: 'Force rebuild (ignore cache)'
        required: false
        type: boolean
        default: false

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-24.04
    timeout-minutes: 120

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Read release configuration
        id: config
        run: |
          # Read config file
          CONFIG_VERSION=$(jq -r '.version' .github/release-config.json)
          CONFIG_NAME=$(jq -r '.name' .github/release-config.json)
          CONFIG_PRERELEASE=$(jq -r '.prerelease' .github/release-config.json)

          # Use input version if provided, otherwise use config
          VERSION="${{ github.event.inputs.version }}"
          if [ -z "$VERSION" ]; then
            VERSION="$CONFIG_VERSION"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "name=$CONFIG_NAME" >> $GITHUB_OUTPUT
          echo "prerelease=$CONFIG_PRERELEASE" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION" >> $GITHUB_OUTPUT

          echo "ðŸ“¦ Building release: v$VERSION ($CONFIG_NAME)"

      - name: Install build dependencies
        run: |
          echo "ðŸ“¥ Installing build tools..."
          sudo apt-get update
          sudo apt-get install -y \
            qemu-user-static \
            debootstrap \
            kpartx \
            parted \
            git \
            zip \
            coreutils \
            quilt \
            libarchive-tools \
            arch-test \
            binfmt-support \
            qemu-utils

          echo "âœ… Dependencies installed"

      - name: Install pi-gen
        run: |
          echo "ðŸ“¥ Installing pi-gen..."
          sudo git clone https://github.com/RPi-Distro/pi-gen /opt/pi-gen
          echo "âœ… pi-gen installed at /opt/pi-gen"

      - name: Clean build directory
        run: |
          echo "ðŸ§¹ Cleaning build directory..."

          # Ensure directories exist before cleaning
          mkdir -p build/pi-gen-work
          mkdir -p logs/successful-builds
          mkdir -p logs/failed-builds

          # Clean previous build artifacts
          if [ -d "build/pi-gen-work" ]; then
            rm -rf build/pi-gen-work/*
            echo "âœ… Build directory cleaned"
          else
            echo "âš ï¸  Build directory did not exist, created it"
          fi

          # Verify critical directories exist
          if [ ! -d "build" ] || [ ! -d "scripts" ] || [ ! -d "assets" ]; then
            echo "âŒ Error: Critical project directories missing!"
            echo "Expected structure:"
            echo "  - build/"
            echo "  - scripts/"
            echo "  - assets/"
            ls -la || true
            exit 1
          fi

          echo "âœ… Directory structure validated"

      - name: Check available disk space
        run: |
          echo "ðŸ“Š Checking available disk space..."
          df -h

          # Get available space in GB for current directory
          AVAILABLE_GB=$(df --output=avail -BG . | tail -1 | tr -d 'G ')
          echo "Available space: ${AVAILABLE_GB}GB"

          # Require at least 15GB for build
          if [ ${AVAILABLE_GB} -lt 15 ]; then
            echo "âŒ Insufficient disk space: ${AVAILABLE_GB}GB available, 15GB required"
            echo "The pi-gen build process requires significant disk space for:"
            echo "  - Downloading Debian packages (~3-4GB)"
            echo "  - Building intermediate images (~5-6GB)"
            echo "  - Final image and compression (~2-3GB)"
            echo "  - Temporary files and caches (~2-3GB)"
            exit 1
          fi

          echo "âœ… Sufficient disk space available (${AVAILABLE_GB}GB)"

      - name: Cache pi-gen downloads
        if: ${{ !inputs.force_rebuild }}
        uses: actions/cache@v3
        with:
          path: |
            build/pi-gen-work/work
            build/pi-gen-work/deploy
          key: pi-gen-cache-${{ hashFiles('build/config', 'build/stage*/**', 'assets/**', 'scripts/build-image.sh', 'scripts/configure-boot.sh') }}
          restore-keys: |
            pi-gen-cache-${{ hashFiles('build/config', 'build/stage*/**') }}-
            pi-gen-cache-

      - name: Build Raspberry Pi image
        timeout-minutes: 90
        run: |
          set -e  # Exit on error for better failure detection

          echo "ðŸ”¨ Starting image build..."
          echo "â±ï¸  This will take approximately 45-60 minutes"
          echo ""

          # Setup timestamped log filename (early for error logging)
          BUILD_TIMESTAMP=$(date -u '+%Y-%m-%d_%H-%M-%S')
          echo "BUILD_TIMESTAMP=${BUILD_TIMESTAMP}" >> $GITHUB_ENV

          # Create early error log in case of catastrophic failure
          mkdir -p build/pi-gen-work
          EARLY_LOG="build/pi-gen-work/build-detailed.log"
          {
            echo "=================================================================="
            echo "  RASPBERRY PI HDMI TESTER - BUILD LOG"
            echo "=================================================================="
            echo ""
            echo "Build Started: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo "Build ID: ${GITHUB_RUN_ID}"
            echo "Build Number: ${GITHUB_RUN_NUMBER}"
            echo "Commit: ${GITHUB_SHA}"
            echo "Branch: ${GITHUB_REF_NAME}"
            echo ""
          } > "${EARLY_LOG}"

          echo "âœ… Early logging initialized at ${EARLY_LOG}"

          # Validate prerequisites before starting build
          echo "ðŸ” Validating prerequisites..."

          if [ ! -x "./scripts/build-image.sh" ]; then
            echo "Making build script executable..."
            chmod +x ./scripts/build-image.sh
          fi

          if [ ! -x "./scripts/logging-utils.sh" ]; then
            echo "Making logging utilities executable..."
            chmod +x ./scripts/logging-utils.sh
          fi

          # Check for required assets
          if [ ! -f "assets/image.png" ]; then
            echo "âŒ Error: Test pattern image not found at assets/image.png"
            echo "Build cannot proceed without test assets"
            {
              echo ""
              echo "ERROR: Missing test pattern image (assets/image.png)"
              echo "Build terminated before starting"
            } >> "${EARLY_LOG}"
            exit 1
          fi

          if [ ! -f "assets/audio.mp3" ]; then
            echo "âŒ Error: Test audio not found at assets/audio.mp3"
            echo "Build cannot proceed without test assets"
            {
              echo ""
              echo "ERROR: Missing test audio file (assets/audio.mp3)"
              echo "Build terminated before starting"
            } >> "${EARLY_LOG}"
            exit 1
          fi

          echo "âœ… All prerequisites validated"

          # Run build (logging handled by build-image.sh)
          # Note: -E preserves environment variables for the build script
          # Required vars: PATH, HOME, USER, GITHUB_* variables
          BUILD_EXIT_CODE=0

          echo "ðŸš€ Launching build script..."
          # Timeout after 5400 seconds (90 minutes) to prevent indefinite hangs
          # This matches the job-level timeout but provides better error reporting
          if timeout 5400 sudo -E ./scripts/build-image.sh; then
            BUILD_EXIT_CODE=0
          else
            BUILD_EXIT_CODE=$?
            if [ ${BUILD_EXIT_CODE} -eq 124 ]; then
              echo "âŒ Build timed out after 90 minutes"
            else
              echo "âš ï¸  Build script exited with code ${BUILD_EXIT_CODE}"
            fi
          fi

          # Store exit code for later steps (with default fallback)
          BUILD_EXIT_CODE="${BUILD_EXIT_CODE:-1}"
          echo "BUILD_EXIT_CODE=${BUILD_EXIT_CODE}" >> $GITHUB_ENV

          # Fix permissions on entire build directory (built with sudo)
          echo "ðŸ”§ Fixing file permissions..."
          if [ -d "build/pi-gen-work" ]; then
            if sudo chown -R runner:runner build/pi-gen-work/; then
              echo "âœ… Permissions fixed"
            else
              echo "âŒ Failed to change ownership of build directory"
              # Don't fail here - we still want to preserve logs
            fi
          else
            echo "âš ï¸  Build directory doesn't exist - build may have failed catastrophically"
          fi

          # Report build status
          if [ ${BUILD_EXIT_CODE} -ne 0 ]; then
            echo ""
            echo "âŒ Build failed with exit code ${BUILD_EXIT_CODE}"
            echo ""

            # Provide troubleshooting hints based on common failure modes
            echo "ðŸ’¡ Troubleshooting Hints:"
            if [ ! -d "build/pi-gen-work" ]; then
              echo "  - Build directory was not created - check directory permissions"
              echo "  - Verify sudo privileges are available"
            elif [ ! -f "build/pi-gen-work/build-detailed.log" ]; then
              echo "  - Log file was not created - build failed during initialization"
              echo "  - Check that logging-utils.sh is properly sourced"
              echo "  - Verify write permissions to build/pi-gen-work/"
            else
              echo "  - Check build-detailed.log for specific error messages"
              echo "  - Common issues: disk space, memory constraints, network failures"
            fi
            echo ""

            # Check if log file exists before promising upload
            if [ -f "build/pi-gen-work/build-detailed.log" ]; then
              echo "ðŸ“ Detailed log will be uploaded as artifact and committed to repository"

              # Show last 30 lines of log for quick debugging
              echo ""
              echo "ðŸ“„ Last 30 lines of build log:"
              echo "----------------------------------------"
              tail -n 30 "build/pi-gen-work/build-detailed.log" || echo "Could not read log file"
              echo "----------------------------------------"
            else
              echo "âš ï¸  Detailed log file not created - build failed early"
              echo "ðŸ“ Minimal error report will be created and committed to repository"
            fi

            exit ${BUILD_EXIT_CODE}
          fi

          echo ""
          echo "âœ… Image build complete"
          echo "ðŸ“ Detailed log available at: build/pi-gen-work/build-detailed.log"

      - name: Upload build logs as artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-${{ env.BUILD_TIMESTAMP }}
          path: build/pi-gen-work/build-detailed.log
          retention-days: 90
          if-no-files-found: warn

      - name: Commit build logs to repository
        if: always()
        run: |
          BUILD_TIMESTAMP="${{ env.BUILD_TIMESTAMP }}"
          BUILD_EXIT_CODE="${{ env.BUILD_EXIT_CODE }}"
          VERSION="${{ steps.config.outputs.version }}"

          # Create logs directories
          mkdir -p logs/successful-builds
          mkdir -p logs/failed-builds

          # Determine log destination and filename
          if [ "${BUILD_EXIT_CODE}" = "0" ]; then
            LOG_DIR="logs/successful-builds"
            LOG_FILE="${LOG_DIR}/build-${BUILD_TIMESTAMP}_v${VERSION}.log"
            echo "ðŸ“ Committing successful build log..."
          else
            LOG_DIR="logs/failed-builds"
            LOG_FILE="${LOG_DIR}/build-${BUILD_TIMESTAMP}_FAILED.log"
            echo "ðŸ“ Committing failed build log..."
          fi

          # Copy log to repository or create error report
          if [ -f "build/pi-gen-work/build-detailed.log" ]; then
            cp build/pi-gen-work/build-detailed.log "${LOG_FILE}"
            echo "âœ… Log file copied"
          elif [ "${BUILD_EXIT_CODE}" != "0" ]; then
            # Build failed before log was created - create minimal error log
            echo "âš ï¸  Build log file not found - creating minimal error report"
            {
              echo "================================================================"
              echo "  RASPBERRY PI HDMI TESTER - BUILD LOG (INCOMPLETE)"
              echo "================================================================"
              echo ""
              echo "Build Started: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
              echo "Build ID: ${GITHUB_RUN_ID}"
              echo "Build Number: ${GITHUB_RUN_NUMBER}"
              echo "Commit: ${GITHUB_SHA}"
              echo "Branch: ${GITHUB_REF_NAME}"
              echo ""
              echo "STATUS: FAILED EARLY (before detailed log could be created)"
              echo ""
              echo "The build failed before the detailed logging system could initialize."
              echo "This typically indicates:"
              echo "- Missing directory creation (build/pi-gen-work not created)"
              echo "- Permission issues with log file path"
              echo "- Script error before logging initialization"
              echo ""
              echo "Check the GitHub Actions workflow output for the actual error message."
              echo ""
              echo "To debug:"
              echo "1. View the workflow run logs in GitHub Actions"
              echo "2. Look for errors in the 'Build Raspberry Pi image' step"
              echo "3. Check if directories exist and are writable"
              echo ""
              echo "================================================================"
              echo "  END OF ERROR REPORT"
              echo "================================================================"
            } > "${LOG_FILE}"
            echo "âœ… Minimal error log created"
          else
            echo "âš ï¸  Build log file not found at build/pi-gen-work/build-detailed.log"
            echo "Build succeeded but no log - this should not happen"
            # Don't commit anything if log is missing on successful build
            exit 0
          fi

          # Compress if larger than 50MB to stay within GitHub limits
          if [ -f "${LOG_FILE}" ]; then
            # Use Linux-compatible stat command (Ubuntu uses GNU stat)
            LOG_SIZE=$(stat -c%s "${LOG_FILE}" 2>/dev/null || echo 0)
            if [ ${LOG_SIZE} -gt 52428800 ]; then
              echo "âš ï¸  Log file is large ($(( LOG_SIZE / 1048576 ))MB), compressing..."
              gzip "${LOG_FILE}"
              LOG_FILE="${LOG_FILE}.gz"
            fi

            # Configure git
            git config --local user.email "github-actions[bot]@users.noreply.github.com"
            git config --local user.name "github-actions[bot]"

            # Add and commit log
            git add "${LOG_FILE}"
            git add logs/README.md logs/.gitkeep 2>/dev/null || true

            if [ "${BUILD_EXIT_CODE}" = "0" ]; then
              git commit -m "logs: Add successful build log for v${VERSION} [${BUILD_TIMESTAMP}]" || echo "No changes to commit"
            else
              git commit -m "logs: Add failed build log [${BUILD_TIMESTAMP}]" || echo "No changes to commit"
            fi

            # Push (only if build succeeded - for failed builds we'll push at the end)
            if [ "${BUILD_EXIT_CODE}" = "0" ]; then
              # Pull latest changes to avoid conflicts
              git pull --rebase origin main || {
                echo "âš ï¸ Rebase failed, trying merge..."
                git pull origin main
              }

              git push || {
                echo "âŒ Failed to push logs"
                exit 1
              }
              echo "âœ… Build log committed and pushed"
            else
              echo "âœ… Build log committed (will push at workflow end)"
            fi
          fi

      - name: Validate built image
        id: validation
        run: |
          echo "ðŸ” Validating built image..."

          VERSION="${{ steps.config.outputs.version }}"
          DEPLOY_DIR="build/pi-gen-work/deploy"

          # Find the built image
          IMAGE_FILE=$(find "${DEPLOY_DIR}" -maxdepth 1 -name "*.img" -type f | head -n 1)

          if [ -z "$IMAGE_FILE" ]; then
            echo "âŒ Error: No image file found for validation!"
            exit 1
          fi

          echo "Found image: $IMAGE_FILE"

          # Make validation script executable
          chmod +x tests/validate-image.sh

          # Run validation (using sudo as it needs to mount partitions)
          if sudo ./tests/validate-image.sh "$IMAGE_FILE"; then
            echo "âœ… Image validation passed"
            echo "validation_status=passed" >> $GITHUB_OUTPUT
          else
            echo "âŒ Image validation failed"
            echo "validation_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Upload validation report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: validation-report-${{ env.BUILD_TIMESTAMP }}
          path: |
            build/validation-*.log
            build/validation-*.txt
          retention-days: 90
          if-no-files-found: ignore

      - name: QEMU boot test (optional)
        id: qemu_test
        continue-on-error: true
        timeout-minutes: 5
        run: |
          echo "ðŸ”§ QEMU Boot Test"
          echo "Note: This test has limitations and may not fully work"
          echo ""

          VERSION="${{ steps.config.outputs.version }}"
          DEPLOY_DIR="build/pi-gen-work/deploy"
          IMAGE_FILE=$(find "${DEPLOY_DIR}" -maxdepth 1 -name "*.img" -type f | head -n 1)

          if [ -z "$IMAGE_FILE" ]; then
            echo "âš ï¸ No image file found for QEMU testing"
            exit 0
          fi

          # Install QEMU ARM system emulator
          echo "ðŸ“¥ Installing QEMU system emulator..."
          sudo apt-get update -qq
          sudo apt-get install -y qemu-system-arm 2>&1 | grep -v "^Reading\|^Building"

          # Create test directory
          TEST_DIR="build/qemu-test"
          mkdir -p "${TEST_DIR}"
          cd "${TEST_DIR}"

          # Extract kernel from image for QEMU
          echo "ðŸ”§ Extracting kernel from image..."

          LOOP_DEVICE=$(sudo losetup -f)
          sudo losetup -P "${LOOP_DEVICE}" "${IMAGE_FILE}"

          BOOT_MOUNT="boot_mount"
          mkdir -p "${BOOT_MOUNT}"

          if sudo mount "${LOOP_DEVICE}p1" "${BOOT_MOUNT}" 2>/dev/null; then
            echo "âœ… Boot partition mounted"

            # Copy kernel
            if [ -f "${BOOT_MOUNT}/kernel8.img" ]; then
              sudo cp "${BOOT_MOUNT}/kernel8.img" "kernel.img"
              echo "âœ… Extracted kernel8.img"
            elif [ -f "${BOOT_MOUNT}/kernel7.img" ]; then
              sudo cp "${BOOT_MOUNT}/kernel7.img" "kernel.img"
              echo "âœ… Extracted kernel7.img"
            else
              echo "âš ï¸ No kernel found, skipping QEMU test"
              sudo umount "${BOOT_MOUNT}" 2>/dev/null || true
              sudo losetup -d "${LOOP_DEVICE}" 2>/dev/null || true
              exit 0
            fi

            # Copy DTB if available
            if [ -f "${BOOT_MOUNT}/bcm2710-rpi-3-b.dtb" ]; then
              sudo cp "${BOOT_MOUNT}/bcm2710-rpi-3-b.dtb" "device-tree.dtb"
              echo "âœ… Extracted device tree"
            fi

            # Cleanup mounts
            sudo umount "${BOOT_MOUNT}" 2>/dev/null || true
            sudo losetup -d "${LOOP_DEVICE}" 2>/dev/null || true
            sudo chmod 644 kernel.img 2>/dev/null || true

            # Attempt basic boot test
            echo ""
            echo "ðŸš€ Attempting QEMU boot test (30 second timeout)..."
            echo "Note: This is expected to fail or hang - RPi images don't boot well in QEMU"
            echo ""

            timeout 30 qemu-system-arm \
              -M versatilepb \
              -cpu arm1176 \
              -m 256 \
              -kernel kernel.img \
              -drive "file=${IMAGE_FILE},format=raw" \
              -append "root=/dev/sda2 rootfstype=ext4 rw console=ttyAMA0" \
              -nographic \
              -serial stdio \
              -no-reboot 2>&1 | head -n 100 > boot-attempt.log || true

            echo ""
            echo "ðŸ“„ Boot attempt log (first 50 lines):"
            head -n 50 boot-attempt.log || true

            # Check for any positive indicators
            if grep -qi "booting\|kernel\|linux" boot-attempt.log; then
              echo "âœ… QEMU showed some boot activity"
              echo "qemu_test_result=partial" >> $GITHUB_OUTPUT
            else
              echo "âš ï¸ QEMU boot test inconclusive"
              echo "qemu_test_result=inconclusive" >> $GITHUB_OUTPUT
            fi
          else
            echo "âš ï¸ Could not mount boot partition, skipping QEMU test"
            sudo losetup -d "${LOOP_DEVICE}" 2>/dev/null || true
            echo "qemu_test_result=skipped" >> $GITHUB_OUTPUT
          fi

      - name: Generate test summary report
        if: success()
        run: |
          echo "ðŸ“Š Generating comprehensive test summary..."

          VERSION="${{ steps.config.outputs.version }}"
          BUILD_DATE=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
          COMMIT_SHA="${{ github.sha }}"
          BUILD_ID="${{ github.run_id }}"
          VALIDATION_STATUS="${{ steps.validation.outputs.validation_status }}"
          QEMU_TEST_RESULT="${{ steps.qemu_test.outputs.qemu_test_result }}"

          REPORT_FILE="build/pi-gen-work/deploy/TESTING_REPORT_v${VERSION}.md"

          # Make script executable
          chmod +x scripts/generate-test-report.sh

          # Generate report
          ./scripts/generate-test-report.sh \
            "${VERSION}" \
            "${BUILD_DATE}" \
            "${COMMIT_SHA}" \
            "${BUILD_ID}" \
            "${VALIDATION_STATUS}" \
            "${QEMU_TEST_RESULT}" \
            "${REPORT_FILE}"

          echo "report_file=${REPORT_FILE}" >> $GITHUB_OUTPUT

          # Display summary
          echo ""
          echo "ðŸ“„ Test Summary Report Preview:"
          echo "================================"
          head -n 30 "${REPORT_FILE}"
          echo "================================"
          echo "(Full report will be included in release assets)"

      - name: Prepare release assets
        id: assets
        run: |
          echo "ðŸ“¦ Preparing release assets..."

          VERSION="${{ steps.config.outputs.version }}"
          DEPLOY_DIR="build/pi-gen-work/deploy"

          # Verify deploy directory exists (should be caught in build step, but double-check)
          if [ ! -d "${DEPLOY_DIR}" ]; then
            echo "âŒ Error: Deploy directory does not exist at ${DEPLOY_DIR}"
            echo "The build may have failed. Check previous step logs."
            exit 1
          fi

          # Fix permissions on deploy directory (built with sudo)
          sudo chown -R runner:runner "${DEPLOY_DIR}" || {
            echo "âŒ Failed to change ownership of deploy directory"
            exit 1
          }

          # Find the built image using proper quoting and find command
          IMAGE_FILE=$(find "${DEPLOY_DIR}" -maxdepth 1 -name "*.img" -type f | head -n 1)

          if [ -z "$IMAGE_FILE" ]; then
            echo "âŒ Error: No image file found!"
            echo "Contents of deploy directory:"
            ls -la "${DEPLOY_DIR}/" || echo "Directory is empty or inaccessible"
            exit 1
          fi

          echo "Found image: $IMAGE_FILE"

          # Create versioned filename
          VERSIONED_IMAGE="RaspberryPi_HDMI_Tester_v${VERSION}.img"
          VERSIONED_ZIP="RaspberryPi_HDMI_Tester_v${VERSION}.img.zip"
          CHECKSUM_FILE="RaspberryPi_HDMI_Tester_v${VERSION}.sha256"

          # Copy and rename image
          cp "$IMAGE_FILE" "${DEPLOY_DIR}/${VERSIONED_IMAGE}"

          # Compress image
          echo "ðŸ—œï¸  Compressing image..."
          cd ${DEPLOY_DIR}
          zip "${VERSIONED_ZIP}" "${VERSIONED_IMAGE}"

          # Generate SHA256 checksums and verification instructions
          echo "ðŸ” Generating checksums and verification instructions..."
          chmod +x ${GITHUB_WORKSPACE}/scripts/generate-checksums.sh
          ${GITHUB_WORKSPACE}/scripts/generate-checksums.sh "${VERSION}" "${DEPLOY_DIR}"

          # Get file sizes
          IMAGE_SIZE=$(ls -lh "${VERSIONED_IMAGE}" | awk '{print $5}')
          ZIP_SIZE=$(ls -lh "${VERSIONED_ZIP}" | awk '{print $5}')

          TESTING_REPORT="TESTING_REPORT_v${VERSION}.md"
          VERIFY_FILE="VERIFY_DOWNLOAD_v${VERSION}.txt"

          echo "image_size=$IMAGE_SIZE" >> $GITHUB_OUTPUT
          echo "zip_size=$ZIP_SIZE" >> $GITHUB_OUTPUT
          echo "zip_path=${DEPLOY_DIR}/${VERSIONED_ZIP}" >> $GITHUB_OUTPUT
          echo "checksum_path=${DEPLOY_DIR}/${CHECKSUM_FILE}" >> $GITHUB_OUTPUT
          echo "testing_report=${DEPLOY_DIR}/${TESTING_REPORT}" >> $GITHUB_OUTPUT
          echo "verify_file=${DEPLOY_DIR}/${VERIFY_FILE}" >> $GITHUB_OUTPUT

          echo "âœ… Assets prepared"
          echo "   Image size: $IMAGE_SIZE"
          echo "   Compressed: $ZIP_SIZE"
          if [ -f "${TESTING_REPORT}" ]; then
            echo "   Testing report: ${TESTING_REPORT}"
          fi
          if [ -f "${VERIFY_FILE}" ]; then
            echo "   Verification instructions: ${VERIFY_FILE}"
          fi

      - name: Generate release notes
        id: notes
        run: |
          VERSION="${{ steps.config.outputs.version }}"
          BUILD_DATE=$(date -u +"%Y-%m-%d %H:%M:%S UTC")

          # Extract data from config
          FEATURES=$(jq -r '.release_notes.features[] | "- " + .' .github/release-config.json)
          COMPATIBILITY=$(jq -r '.release_notes.compatibility[] | "- " + .' .github/release-config.json)
          KNOWN_ISSUES=$(jq -r '.release_notes.known_issues[] | "- " + .' .github/release-config.json)
          BASE_OS=$(jq -r '.build.base_os' .github/release-config.json)
          BUILD_SYSTEM=$(jq -r '.build.build_system' .github/release-config.json)

          # Generate release notes
          cat > release_notes.md << EOF
          # Raspberry Pi HDMI Tester v${{ steps.config.outputs.version }}

          ## ðŸ“¦ Release: ${{ steps.config.outputs.name }}

          **Build Date:** ${BUILD_DATE}
          **Commit:** ${{ github.sha }}

          ---

          ## âœ¨ Features

          ${FEATURES}

          ## ðŸ”§ Compatibility

          Tested and compatible with:
          ${COMPATIBILITY}

          ## âš ï¸ Known Issues

          ${KNOWN_ISSUES}

          ---

          ## ðŸ“¥ Installation

          ### Quick Start (Windows 11)

          1. **Download** \`RaspberryPi_HDMI_Tester_v${{ steps.config.outputs.version }}.img.zip\`
          2. **Extract** the \`.img\` file from the ZIP archive
          3. **Flash** to SD card using [Raspberry Pi Imager](https://www.raspberrypi.com/software/)
          4. **Insert** SD card into Raspberry Pi
          5. **Connect** HDMI to display
          6. **Power on** - it will boot automatically!

          ### Verification

          Verify the download integrity:
          \`\`\`bash
          sha256sum -c RaspberryPi_HDMI_Tester_v${{ steps.config.outputs.version }}.sha256
          \`\`\`

          ### Full Documentation

          - ðŸ“– [Building Guide](https://github.com/benpaddlejones/Raspberry_HDMI_Tester/blob/main/docs/BUILDING.md)
          - ðŸ’¾ [Flashing Guide](https://github.com/benpaddlejones/Raspberry_HDMI_Tester/blob/main/docs/FLASHING.md)
          - ðŸŽ¨ [Customization Guide](https://github.com/benpaddlejones/Raspberry_HDMI_Tester/blob/main/docs/CUSTOMIZATION.md)
          - ðŸ”§ [Troubleshooting Guide](https://github.com/benpaddlejones/Raspberry_HDMI_Tester/blob/main/docs/TROUBLESHOOTING.md)

          ---

          ## ðŸ“Š Build Information

          - **Base OS:** ${BASE_OS}
          - **Build System:** ${BUILD_SYSTEM}
          - **Image Size:** ${{ steps.assets.outputs.image_size }}
          - **Compressed Size:** ${{ steps.assets.outputs.zip_size }}

          ---

          ## ðŸ› Issues & Support

          Found a bug? Have a question?
          - [Report an Issue](https://github.com/benpaddlejones/Raspberry_HDMI_Tester/issues)
          - [View Documentation](https://github.com/benpaddlejones/Raspberry_HDMI_Tester#readme)
          EOF

          cat release_notes.md

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.config.outputs.tag }}
          name: "v${{ steps.config.outputs.version }} - ${{ steps.config.outputs.name }}"
          body_path: release_notes.md
          files: |
            ${{ steps.assets.outputs.zip_path }}
            ${{ steps.assets.outputs.checksum_path }}
            ${{ steps.assets.outputs.testing_report }}
            ${{ steps.assets.outputs.verify_file }}
          draft: false
          prerelease: ${{ steps.config.outputs.prerelease }}
          make_latest: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update README with release link
        run: |
          VERSION="${{ steps.config.outputs.version }}"
          TAG="${{ steps.config.outputs.tag }}"

          # Create download section content
          cat > download_section.md << 'DOWNLOADEOF'

          ## ðŸ“¥ Download

          [![Latest Release](https://img.shields.io/github/v/release/benpaddlejones/Raspberry_HDMI_Tester?label=Latest%20Release&style=for-the-badge)](https://github.com/benpaddlejones/Raspberry_HDMI_Tester/releases/latest)
          [![Downloads](https://img.shields.io/github/downloads/benpaddlejones/Raspberry_HDMI_Tester/total?style=for-the-badge)](https://github.com/benpaddlejones/Raspberry_HDMI_Tester/releases)

          **Latest Version:** [VERSION_TAG](https://github.com/benpaddlejones/Raspberry_HDMI_Tester/releases/tag/VERSION_TAG)

          Download the pre-built image and flash to your SD card.
          DOWNLOADEOF

          # Replace placeholders
          sed -i "s/VERSION_TAG/$TAG/g" download_section.md
          sed -i "s/VERSION_NUM/v$VERSION/g" download_section.md

          # Replace Download section (remove old, add new)
          if grep -q "## ðŸ“¥ Download" README.md; then
            # Section exists - replace it
            echo "Updating existing Download section..."

            # Find start and end of Download section
            START_LINE=$(grep -n "## ðŸ“¥ Download" README.md | head -n1 | cut -d: -f1)
            # Find next ## heading or end of file
            NEXT_SECTION=$(tail -n +$((START_LINE + 1)) README.md | grep -n "^## " | head -n1 | cut -d: -f1)

            if [ -n "$NEXT_SECTION" ]; then
              END_LINE=$((START_LINE + NEXT_SECTION - 1))
              # Delete old section
              sed -i "${START_LINE},${END_LINE}d" README.md
            else
              # Download section is at end of file
              sed -i "${START_LINE},\$d" README.md
            fi

            # Insert new section at the same position
            sed -i "${START_LINE}r download_section.md" README.md
            echo "âœ… Download section updated"
          else
            # Section doesn't exist - add after Project Overview
            sed -i '/## Project Overview/r download_section.md' README.md
            echo "âœ… Download section added to README"
          fi

          rm -f download_section.md

      - name: Commit README changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          git add README.md

          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "docs: Update README with release v${{ steps.config.outputs.version }} links [skip ci]"

            # Pull latest changes before pushing (in case logs were committed)
            git pull --rebase origin main || {
              echo "âš ï¸ Rebase failed, trying merge..."
              git pull origin main
            }

            git push || {
              echo "âŒ Failed to push README updates"
              exit 1
            }

            echo "âœ… README updates pushed successfully"
          fi

      - name: Push failed build logs
        if: failure()
        run: |
          # If build failed, push the committed logs now
          echo "ðŸ“ Pushing failed build logs to repository..."

          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          # Check if there are commits to push
          if git log origin/main..HEAD --oneline | grep -q .; then
            echo "Found commits to push..."

            git pull --rebase origin main || {
              echo "âš ï¸ Rebase failed, trying merge..."
              git pull origin main
            }

            git push || {
              echo "âŒ CRITICAL: Failed to push failed build logs"
              echo "Manual intervention required to push logs"
              exit 1
            }

            echo "âœ… Failed build logs pushed successfully"
          else
            echo "No commits to push (logs may already be pushed)"
          fi

      - name: Build summary
        if: always()
        run: |
          BUILD_EXIT_CODE="${{ env.BUILD_EXIT_CODE }}"
          BUILD_TIMESTAMP="${{ env.BUILD_TIMESTAMP }}"
          VALIDATION_STATUS="${{ steps.validation.outputs.validation_status }}"
          QEMU_TEST_RESULT="${{ steps.qemu_test.outputs.qemu_test_result }}"

          if [ "${BUILD_EXIT_CODE}" = "0" ]; then
            echo "## ðŸŽ‰ Release Build Complete!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Version:** v${{ steps.config.outputs.version }}" >> $GITHUB_STEP_SUMMARY
            echo "- Image (compressed): ${{ steps.assets.outputs.zip_size }}" >> $GITHUB_STEP_SUMMARY
            echo "- Image (uncompressed): ${{ steps.assets.outputs.image_size }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            echo "### âœ… Validation Results:" >> $GITHUB_STEP_SUMMARY
            echo "- **Image Validation:** ${VALIDATION_STATUS:-unknown}" >> $GITHUB_STEP_SUMMARY
            echo "- **QEMU Boot Test:** ${QEMU_TEST_RESULT:-not run}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            echo "### ðŸ”— Release URL:" >> $GITHUB_STEP_SUMMARY
            echo "[View Release](https://github.com/benpaddlejones/Raspberry_HDMI_Tester/releases/tag/${{ steps.config.outputs.tag }})" >> $GITHUB_STEP_SUMMARY
          else
            echo "## âŒ Build Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Build Timestamp:** ${BUILD_TIMESTAMP}" >> $GITHUB_STEP_SUMMARY
            echo "**Exit Code:** ${BUILD_EXIT_CODE}" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“ Build Logs:" >> $GITHUB_STEP_SUMMARY
          echo "- **Detailed Log (Artifact):** Available in workflow artifacts (retained for 90 days)" >> $GITHUB_STEP_SUMMARY
          echo "- **Committed Log:** Check \`logs/\` directory in repository" >> $GITHUB_STEP_SUMMARY

          if [ -f "build/pi-gen-work/build-detailed.log" ]; then
            LOG_SIZE=$(stat -f%z "build/pi-gen-work/build-detailed.log" 2>/dev/null || stat -c%s "build/pi-gen-work/build-detailed.log")
            LOG_SIZE_MB=$(( LOG_SIZE / 1048576 ))
            echo "- **Log Size:** ${LOG_SIZE_MB}MB" >> $GITHUB_STEP_SUMMARY
          fi

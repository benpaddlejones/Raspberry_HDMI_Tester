name: Build and Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (from release-config.json or override)'
        required: false
        default: ''
      force_rebuild:
        description: 'Force rebuild (ignore cache)'
        required: false
        type: boolean
        default: false

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-24.04
    timeout-minutes: 120

    steps:
      - name: Checkout repository with submodules
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'

      - name: Read release configuration
        id: config
        run: |
          # Read config file
          CONFIG_VERSION=$(jq -r '.version' .github/release-config.json)
          CONFIG_NAME=$(jq -r '.name' .github/release-config.json)
          CONFIG_PRERELEASE=$(jq -r '.prerelease' .github/release-config.json)

          # Use input version if provided, otherwise use config
          VERSION="${{ github.event.inputs.version }}"
          if [ -z "$VERSION" ]; then
            VERSION="$CONFIG_VERSION"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "name=$CONFIG_NAME" >> $GITHUB_OUTPUT
          echo "prerelease=$CONFIG_PRERELEASE" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION" >> $GITHUB_OUTPUT

          echo "ðŸ“¦ Building release: v$VERSION ($CONFIG_NAME)"

      - name: Install build dependencies
        run: |
          echo "ðŸ“¥ Installing build tools..."
          sudo apt-get update
          sudo apt-get install -y \
            quilt \
            parted \
            coreutils \
            qemu-user-static \
            debootstrap \
            zerofree \
            zip \
            dosfstools \
            e2fsprogs \
            libcap2-bin \
            libarchive-tools \
            grep \
            rsync \
            xz-utils \
            curl \
            xxd \
            file \
            git \
            kmod \
            bc \
            gpg \
            pigz \
            arch-test \
            binfmt-support \
            kpartx \
            qemu-utils

          echo "âœ… Dependencies installed"

      - name: Install QEMU kernel for boot testing
        run: |
          echo "ðŸ“¥ Installing QEMU ARM kernel for testing..."

          # Create QEMU directory
          sudo mkdir -p /usr/share/qemu

          # Download versatilepb kernel from dhruvvyas90/qemu-rpi-kernel
          # This is a known-good kernel for QEMU ARM emulation
          KERNEL_URL="https://github.com/dhruvvyas90/qemu-rpi-kernel/raw/master/kernel-qemu-4.19.50-buster"
          DTB_URL="https://github.com/dhruvvyas90/qemu-rpi-kernel/raw/master/versatile-pb.dtb"

          echo "Downloading QEMU ARM kernel..."
          sudo curl -L -o /usr/share/qemu/qemu-arm-kernel "${KERNEL_URL}"

          echo "Downloading device tree blob..."
          sudo curl -L -o /usr/share/qemu/versatile-pb.dtb "${DTB_URL}"

          # Set permissions
          sudo chmod 644 /usr/share/qemu/qemu-arm-kernel
          sudo chmod 644 /usr/share/qemu/versatile-pb.dtb

          # Verify files exist and have content
          if [ -f /usr/share/qemu/qemu-arm-kernel ] && [ -s /usr/share/qemu/qemu-arm-kernel ]; then
            KERNEL_SIZE=$(stat -c%s /usr/share/qemu/qemu-arm-kernel)
            echo "âœ… QEMU kernel installed: ${KERNEL_SIZE} bytes"
          else
            echo "âŒ Failed to install QEMU kernel"
            exit 1
          fi

          echo "âœ… QEMU kernel and DTB installed"

      - name: Enable binfmt_misc for ARM emulation
        run: |
          echo "ðŸ”§ Enabling binfmt_misc kernel module for ARM emulation..."

          # Check if binfmt_misc is available as a module
          if [ -f /proc/sys/fs/binfmt_misc/status ]; then
            echo "âœ… binfmt_misc already enabled via filesystem"
          else
            # Try to mount binfmt_misc filesystem
            sudo mount binfmt_misc -t binfmt_misc /proc/sys/fs/binfmt_misc 2>/dev/null || true

            if [ -f /proc/sys/fs/binfmt_misc/status ]; then
              echo "âœ… binfmt_misc mounted successfully"
            else
              echo "âš ï¸  binfmt_misc not available via mount, checking systemd service..."
            fi
          fi

          # Ensure qemu-user-static registers ARM emulation
          echo "ðŸ”§ Registering QEMU ARM handlers..."
          sudo systemctl restart systemd-binfmt.service || true

          # Verify registration
          if [ -f /proc/sys/fs/binfmt_misc/qemu-arm ]; then
            echo "âœ… QEMU ARM handler registered"
            cat /proc/sys/fs/binfmt_misc/qemu-arm
          else
            echo "âš ï¸  QEMU ARM handler not found, manually registering..."
            sudo update-binfmts --enable qemu-arm || true
          fi

          echo "âœ… ARM emulation configured"

      - name: Install pi-gen
        run: |
          echo "ðŸ“¥ Installing pi-gen..."
          sudo git clone https://github.com/RPi-Distro/pi-gen /opt/pi-gen
          echo "âœ… pi-gen installed at /opt/pi-gen"

      - name: Clean build directory
        run: |
          echo "ðŸ§¹ Cleaning build directory..."

          # Ensure directories exist before cleaning
          mkdir -p build/pi-gen-work
          mkdir -p logs/successful-builds
          mkdir -p logs/failed-builds

          # Clean previous build artifacts (use sudo in case files were created with elevated permissions)
          if [ -d "build/pi-gen-work" ]; then
            echo "Removing previous build artifacts..."
            sudo rm -rf build/pi-gen-work/* || {
              echo "âŒ Failed to clean build directory"
              echo "Attempting to continue anyway..."
            }
            echo "âœ… Build directory cleaned"
          else
            echo "âš ï¸  Build directory did not exist, created it"
          fi

          # Verify critical directories exist
          if [ ! -d "build" ] || [ ! -d "scripts" ]; then
            echo "âŒ Error: Critical project directories missing!"
            echo "Expected structure:"
            echo "  - build/"
            echo "  - scripts/"
            ls -la || true
            exit 1
          fi

          # Verify asset files exist
          echo "Checking asset files..."
          if [ ! -d "build/stage3/01-test-image/files" ]; then
            echo "âŒ Error: Asset directory missing: build/stage3/01-test-image/files/"
            exit 1
          fi

          ASSET_COUNT=$(find build/stage3/01-test-image/files -name "*.webm" -type f | wc -l)
          echo "Found ${ASSET_COUNT} WebM asset file(s)"

          if [ ${ASSET_COUNT} -lt 2 ]; then
            echo "âš ï¸  Warning: Expected 2 WebM files (image-test.webm, color-test.webm)"
            echo "Contents of asset directory:"
            ls -la build/stage3/01-test-image/files/
          fi

          echo "âœ… Directory structure validated"

      - name: Check available disk space and memory
        run: |
          echo "ðŸ“Š Checking system resources..."
          echo ""
          echo "=== Disk Space ==="
          df -h
          echo ""
          echo "=== Memory ==="
          free -h
          echo ""

          # Get available space in GB for current directory
          AVAILABLE_GB=$(df --output=avail -BG . | tail -1 | tr -d 'G ')
          echo "Available disk space: ${AVAILABLE_GB}GB"

          # Require at least 15GB for build
          if [ ${AVAILABLE_GB} -lt 15 ]; then
            echo "âŒ Insufficient disk space: ${AVAILABLE_GB}GB available, 15GB required"
            echo "The pi-gen build process requires significant disk space for:"
            echo "  - Downloading Debian packages (~3-4GB)"
            echo "  - Building intermediate images (~5-6GB)"
            echo "  - Final image and compression (~2-3GB)"
            echo "  - Temporary files and caches (~2-3GB)"
            exit 1
          fi

          echo "âœ… Sufficient disk space available (${AVAILABLE_GB}GB)"

          # Check available memory
          AVAILABLE_MEM_GB=$(free -g | awk '/^Mem:/{print $7}')
          echo "Available memory: ${AVAILABLE_MEM_GB}GB"

          if [ ${AVAILABLE_MEM_GB} -lt 2 ]; then
            echo "âš ï¸  Warning: Low memory (${AVAILABLE_MEM_GB}GB available)"
            echo "Build may be slower or fail if memory is exhausted"
          else
            echo "âœ… Sufficient memory available"
          fi

      - name: Cache pi-gen downloads
        if: ${{ !inputs.force_rebuild }}
        uses: actions/cache@v3
        with:
          path: |
            build/pi-gen-work/work
            build/pi-gen-work/deploy
          key: pi-gen-cache-${{ hashFiles('build/config', 'build/stage*/**', 'assets/**', 'scripts/build-image.sh', 'scripts/configure-boot.sh') }}
          restore-keys: |
            pi-gen-cache-${{ hashFiles('build/config', 'build/stage*/**') }}-
            pi-gen-cache-

      - name: Cache APT packages
        if: ${{ !inputs.force_rebuild }}
        uses: actions/cache@v3
        with:
          path: |
            /var/cache/apt/archives/*.deb
            /var/lib/apt/lists/*
          key: apt-cache-${{ runner.os }}-${{ hashFiles('build/stage*/*/00-packages*') }}
          restore-keys: |
            apt-cache-${{ runner.os }}-

      - name: Start disk space monitoring
        run: |
          echo "ðŸ’¾ Starting disk space monitoring..."

          # Create monitoring script
          cat > /tmp/disk-monitor.sh << 'EOF'
          #!/bin/bash
          # Disk space monitoring script - runs in background during build

          LOG_FILE="/tmp/disk-monitor.log"
          echo "Disk Space Monitor started at $(date)" > "${LOG_FILE}"
          echo "Monitoring interval: 5 minutes" >> "${LOG_FILE}"
          echo "Warning threshold: 85%" >> "${LOG_FILE}"
          echo "Critical threshold: 90%" >> "${LOG_FILE}"
          echo "" >> "${LOG_FILE}"

          while true; do
            # Get disk usage percentage for root filesystem
            USAGE=$(df --output=pcent / | tail -1 | tr -d '% ')
            TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

            # Log current usage
            echo "[${TIMESTAMP}] Disk usage: ${USAGE}%" >> "${LOG_FILE}"

            # Check thresholds
            if [ "${USAGE}" -gt 90 ]; then
              echo "âŒ CRITICAL: Disk usage at ${USAGE}% - Build cannot continue safely" | tee -a "${LOG_FILE}"
              echo "" | tee -a "${LOG_FILE}"
              echo "Current disk usage:" | tee -a "${LOG_FILE}"
              df -h / | tee -a "${LOG_FILE}"
              echo "" | tee -a "${LOG_FILE}"
              echo "Largest directories:" | tee -a "${LOG_FILE}"
              du -h --max-depth=2 /home/runner/work 2>/dev/null | sort -hr | head -10 | tee -a "${LOG_FILE}"
              exit 1
            elif [ "${USAGE}" -gt 85 ]; then
              echo "âš ï¸  WARNING: Disk usage at ${USAGE}% - Approaching critical threshold" | tee -a "${LOG_FILE}"
              df -h / | tee -a "${LOG_FILE}"
            fi

            # Wait 5 minutes before next check
            sleep 300
          done
          EOF

          chmod +x /tmp/disk-monitor.sh

          # Start monitor in background
          nohup /tmp/disk-monitor.sh &
          MONITOR_PID=$!
          echo "${MONITOR_PID}" > /tmp/disk-monitor.pid

          echo "âœ… Disk space monitor started (PID: ${MONITOR_PID})"
          echo "ðŸ“Š Initial disk status:"
          df -h /
          echo ""
          echo "Monitor will check every 5 minutes and alert if usage exceeds 85%"

      - name: Build Raspberry Pi image
        timeout-minutes: 90
        run: |
          set -e  # Exit on error for better failure detection

          echo "ðŸ”¨ Starting image build..."
          echo "â±ï¸  This will take approximately 45-60 minutes"
          echo ""

          # Setup timestamped log filename (early for error logging)
          BUILD_TIMESTAMP=$(date -u '+%Y-%m-%d_%H-%M-%S')
          echo "BUILD_TIMESTAMP=${BUILD_TIMESTAMP}" >> $GITHUB_ENV

          # Create early error log in case of catastrophic failure
          mkdir -p build/pi-gen-work
          EARLY_LOG="build/pi-gen-work/build-detailed.log"
          {
            echo "=================================================================="
            echo "  RASPBERRY PI HDMI TESTER - BUILD LOG"
            echo "=================================================================="
            echo ""
            echo "Build Started: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo "Build ID: ${GITHUB_RUN_ID}"
            echo "Build Number: ${GITHUB_RUN_NUMBER}"
            echo "Commit: ${GITHUB_SHA}"
            echo "Branch: ${GITHUB_REF_NAME}"
            echo ""
          } > "${EARLY_LOG}"

          echo "âœ… Early logging initialized at ${EARLY_LOG}"

          # Validate prerequisites before starting build
          echo "ðŸ” Validating prerequisites..."

          if [ ! -x "./scripts/build-image.sh" ]; then
            echo "Making build script executable..."
            chmod +x ./scripts/build-image.sh
          fi

          if [ ! -x "./scripts/logging-utils.sh" ]; then
            echo "Making logging utilities executable..."
            chmod +x ./scripts/logging-utils.sh
          fi

          # Check for required assets
          if [ ! -f "assets/image.png" ]; then
            echo "âŒ Error: Test pattern image not found at assets/image.png"
            echo "Build cannot proceed without test assets"
            {
              echo ""
              echo "ERROR: Missing test pattern image (assets/image.png)"
              echo "Build terminated before starting"
            } >> "${EARLY_LOG}"
            exit 1
          fi

          if [ ! -f "assets/stereo.flac" ] || [ ! -f "assets/surround51.flac" ]; then
            echo "âŒ Error: Test audio files not found (stereo.flac and surround51.flac required)"
            echo "Build cannot proceed without test assets"
            {
              echo ""
              echo "ERROR: Missing test audio files (assets/stereo.flac and assets/surround51.flac)"
              echo "Build terminated before starting"
            } >> "${EARLY_LOG}"
            exit 1
          fi

          echo "âœ… All prerequisites validated"

          # Run build (logging handled by build-image.sh)
          # Note: -E preserves environment variables for the build script
          # Required vars: PATH, HOME, USER, GITHUB_* variables
          BUILD_EXIT_CODE=0

          echo "ðŸš€ Launching build script..."
          # Timeout after 5400 seconds (90 minutes) to prevent indefinite hangs
          # This matches the job-level timeout but provides better error reporting
          if timeout 5400 sudo -E ./scripts/build-image.sh; then
            BUILD_EXIT_CODE=0
          else
            BUILD_EXIT_CODE=$?
            if [ ${BUILD_EXIT_CODE} -eq 124 ]; then
              echo "âŒ Build timed out after 90 minutes"
            else
              echo "âš ï¸  Build script exited with code ${BUILD_EXIT_CODE}"
            fi
          fi

          # Store exit code for later steps (with default fallback)
          BUILD_EXIT_CODE="${BUILD_EXIT_CODE:-1}"
          echo "BUILD_EXIT_CODE=${BUILD_EXIT_CODE}" >> $GITHUB_ENV

          # Fix permissions on entire build directory (built with sudo)
          echo "ðŸ”§ Fixing file permissions..."
          if [ -d "build/pi-gen-work" ]; then
            if sudo chown -R runner:runner build/pi-gen-work/; then
              echo "âœ… Permissions fixed"
            else
              echo "âŒ Failed to change ownership of build directory"
              # Don't fail here - we still want to preserve logs
            fi
          else
            echo "âš ï¸  Build directory doesn't exist - build may have failed catastrophically"
          fi

          # Report build status
          if [ ${BUILD_EXIT_CODE} -ne 0 ]; then
            echo ""
            echo "âŒ Build failed with exit code ${BUILD_EXIT_CODE}"
            echo ""

            # Provide troubleshooting hints based on common failure modes
            echo "ðŸ’¡ Troubleshooting Hints:"
            if [ ! -d "build/pi-gen-work" ]; then
              echo "  - Build directory was not created - check directory permissions"
              echo "  - Verify sudo privileges are available"
            elif [ ! -f "build/pi-gen-work/build-detailed.log" ]; then
              echo "  - Log file was not created - build failed during initialization"
              echo "  - Check that logging-utils.sh is properly sourced"
              echo "  - Verify write permissions to build/pi-gen-work/"
            else
              echo "  - Check build-detailed.log for specific error messages"
              echo "  - Common issues: disk space, memory constraints, network failures"
            fi
            echo ""

            # Check if log file exists before promising upload
            if [ -f "build/pi-gen-work/build-detailed.log" ]; then
              echo "ðŸ“ Detailed log will be uploaded as artifact and committed to repository"

              # Show last 30 lines of log for quick debugging
              echo ""
              echo "ðŸ“„ Last 30 lines of build log:"
              echo "----------------------------------------"
              tail -n 30 "build/pi-gen-work/build-detailed.log" || echo "Could not read log file"
              echo "----------------------------------------"
            else
              echo "âš ï¸  Detailed log file not created - build failed early"
              echo "ðŸ“ Minimal error report will be created and committed to repository"
            fi

            exit ${BUILD_EXIT_CODE}
          fi

          echo ""
          echo "âœ… Image build complete"
          echo "ðŸ“ Detailed log available at: build/pi-gen-work/build-detailed.log"

      - name: Stop disk space monitoring
        if: always()
        run: |
          echo "ðŸ›‘ Stopping disk space monitor..."

          # Stop the background monitor process
          if [ -f /tmp/disk-monitor.pid ]; then
            MONITOR_PID=$(cat /tmp/disk-monitor.pid)
            if kill "${MONITOR_PID}" 2>/dev/null; then
              echo "âœ… Monitor stopped (PID: ${MONITOR_PID})"
            else
              echo "âš ï¸  Monitor process ${MONITOR_PID} not found (may have already exited)"
            fi
            rm -f /tmp/disk-monitor.pid
          else
            echo "âš ï¸  Monitor PID file not found"
          fi

          # Display monitor log summary
          if [ -f /tmp/disk-monitor.log ]; then
            echo ""
            echo "ðŸ“Š Disk Space Monitor Summary:"
            echo "----------------------------------------"
            cat /tmp/disk-monitor.log
            echo "----------------------------------------"

            # Check if there were any warnings
            if grep -q "WARNING" /tmp/disk-monitor.log; then
              echo ""
              echo "âš ï¸  Disk space warnings were logged during build"
            fi

            # Check if critical threshold was hit
            if grep -q "CRITICAL" /tmp/disk-monitor.log; then
              echo ""
              echo "âŒ CRITICAL disk space threshold was exceeded"
            fi
          else
            echo "âš ï¸  Monitor log file not found"
          fi

          # Final disk status
          echo ""
          echo "ðŸ“Š Final disk status:"
          df -h /
          echo ""
          echo "ðŸ“ Largest directories in workspace:"
          du -h --max-depth=2 /home/runner/work 2>/dev/null | sort -hr | head -10 || echo "Could not analyze disk usage"

      - name: Upload build logs as artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-${{ env.BUILD_TIMESTAMP }}
          path: build/pi-gen-work/build-detailed.log
          retention-days: 90
          if-no-files-found: warn

      - name: Commit build logs to repository
        if: always()
        run: |
          BUILD_TIMESTAMP="${{ env.BUILD_TIMESTAMP }}"
          BUILD_EXIT_CODE="${{ env.BUILD_EXIT_CODE }}"
          VERSION="${{ steps.config.outputs.version }}"

          # Create logs directories
          mkdir -p logs/successful-builds
          mkdir -p logs/failed-builds

          # Determine log destination and filename
          if [ "${BUILD_EXIT_CODE}" = "0" ]; then
            LOG_DIR="logs/successful-builds"
            LOG_FILE="${LOG_DIR}/build-${BUILD_TIMESTAMP}_v${VERSION}.log"
            echo "ðŸ“ Committing successful build log..."
          else
            LOG_DIR="logs/failed-builds"
            LOG_FILE="${LOG_DIR}/build-${BUILD_TIMESTAMP}_FAILED.log"
            echo "ðŸ“ Committing failed build log..."
          fi

          # Copy log to repository or create error report
          if [ -f "build/pi-gen-work/build-detailed.log" ]; then
            cp build/pi-gen-work/build-detailed.log "${LOG_FILE}"
            echo "âœ… Log file copied"
          elif [ "${BUILD_EXIT_CODE}" != "0" ]; then
            # Build failed before log was created - create minimal error log
            echo "âš ï¸  Build log file not found - creating minimal error report"
            {
              echo "================================================================"
              echo "  RASPBERRY PI HDMI TESTER - BUILD LOG (INCOMPLETE)"
              echo "================================================================"
              echo ""
              echo "Build Started: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
              echo "Build ID: ${GITHUB_RUN_ID}"
              echo "Build Number: ${GITHUB_RUN_NUMBER}"
              echo "Commit: ${GITHUB_SHA}"
              echo "Branch: ${GITHUB_REF_NAME}"
              echo ""
              echo "STATUS: FAILED EARLY (before detailed log could be created)"
              echo ""
              echo "The build failed before the detailed logging system could initialize."
              echo "This typically indicates:"
              echo "- Missing directory creation (build/pi-gen-work not created)"
              echo "- Permission issues with log file path"
              echo "- Script error before logging initialization"
              echo ""
              echo "Check the GitHub Actions workflow output for the actual error message."
              echo ""
              echo "To debug:"
              echo "1. View the workflow run logs in GitHub Actions"
              echo "2. Look for errors in the 'Build Raspberry Pi image' step"
              echo "3. Check if directories exist and are writable"
              echo ""
              echo "================================================================"
              echo "  END OF ERROR REPORT"
              echo "================================================================"
            } > "${LOG_FILE}"
            echo "âœ… Minimal error log created"
          else
            echo "âš ï¸  Build log file not found at build/pi-gen-work/build-detailed.log"
            echo "Build succeeded but no log - this should not happen"
            # Don't commit anything if log is missing on successful build
            exit 0
          fi

          # Compress if larger than 50MB to stay within GitHub limits
          if [ -f "${LOG_FILE}" ]; then
            # Use Linux-compatible stat command (Ubuntu uses GNU stat)
            LOG_SIZE=$(stat -c%s "${LOG_FILE}" 2>/dev/null || echo 0)
            if [ ${LOG_SIZE} -gt 52428800 ]; then
              echo "âš ï¸  Log file is large ($(( LOG_SIZE / 1048576 ))MB), compressing..."
              gzip "${LOG_FILE}"
              LOG_FILE="${LOG_FILE}.gz"
            fi

            # Configure git
            git config --local user.email "github-actions[bot]@users.noreply.github.com"
            git config --local user.name "github-actions[bot]"

            # Add and commit log
            git add "${LOG_FILE}"
            git add logs/README.md logs/.gitkeep 2>/dev/null || true

            if [ "${BUILD_EXIT_CODE}" = "0" ]; then
              git commit -m "logs: Add successful build log for v${VERSION} [${BUILD_TIMESTAMP}]" || echo "No changes to commit"
            else
              git commit -m "logs: Add failed build log [${BUILD_TIMESTAMP}]" || echo "No changes to commit"
            fi

            # Push (only if build succeeded - for failed builds we'll push at the end)
            if [ "${BUILD_EXIT_CODE}" = "0" ]; then
              # Pull latest changes to avoid conflicts
              git pull --rebase origin ${GITHUB_REF_NAME} || {
                echo "âš ï¸ Rebase failed, trying merge..."
                git pull origin ${GITHUB_REF_NAME}
              }

              git push || {
                echo "âŒ Failed to push logs"
                exit 1
              }
              echo "âœ… Build log committed and pushed"
            else
              echo "âœ… Build log committed (will push at workflow end)"
            fi
          fi

      - name: Validate built image
        id: validation
        run: |
          echo "ðŸ” Validating built image..."

          VERSION="${{ steps.config.outputs.version }}"
          DEPLOY_DIR="build/pi-gen-work/deploy"

          # Find the built image (check for .img first, then .zip)
          IMAGE_FILE=$(find "${DEPLOY_DIR}" -maxdepth 1 -name "*.img" -type f | head -n 1)

          if [ -z "$IMAGE_FILE" ]; then
            echo "âš ï¸  No .img file found, checking for .zip files..."
            ZIP_FILE=$(find "${DEPLOY_DIR}" -maxdepth 1 -name "*hdmi-tester*.zip" -type f | head -n 1)

            if [ -z "$ZIP_FILE" ]; then
              echo "âŒ Error: No .img or .zip file found for validation!"
              echo "Contents of deploy directory:"
              ls -la "${DEPLOY_DIR}/"
              exit 1
            fi

            echo "Found ZIP file: ${ZIP_FILE}"
            echo "ðŸ“¦ Extracting image from ZIP..."

            # Extract the .img file from the zip
            if unzip -o "${ZIP_FILE}" -d "${DEPLOY_DIR}/" "*.img"; then
              echo "âœ… ZIP extraction successful"
              IMAGE_FILE=$(find "${DEPLOY_DIR}" -maxdepth 1 -name "*.img" -type f | head -n 1)

              if [ -z "$IMAGE_FILE" ]; then
                echo "âŒ No .img file found after extraction!"
                exit 1
              fi
            else
              echo "âŒ Failed to extract ZIP file!"
              exit 1
            fi
          fi

          echo "Found image: $IMAGE_FILE"

          # Make validation script executable
          chmod +x tests/validate-image.sh

          # Run validation (using sudo as it needs to mount partitions)
          if sudo ./tests/validate-image.sh "$IMAGE_FILE"; then
            echo "âœ… Image validation passed"
            echo "validation_status=passed" >> $GITHUB_OUTPUT
          else
            echo "âŒ Image validation failed"
            echo "validation_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Upload validation report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: validation-report-${{ env.BUILD_TIMESTAMP }}
          path: |
            build/validation-*.log
            build/validation-*.txt
          retention-days: 90
          if-no-files-found: ignore

      - name: Upload QEMU test logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: qemu-test-logs-${{ env.BUILD_TIMESTAMP }}
          path: |
            build/qemu-testing/*.log
            build/qemu-testing/boot-*.log
            build/qemu-testing/kernel.img
          retention-days: 90
          if-no-files-found: ignore

      - name: QEMU boot test (optional)
        id: qemu_test
        continue-on-error: true
        timeout-minutes: 5
        run: |
          set -x  # Enable extremely verbose bash debugging

          echo "=================================================================="
          echo "  QEMU BOOT TEST - VERBOSE MODE"
          echo "=================================================================="
          echo "Note: This test has limitations and may not fully work"
          echo "RPi images don't boot perfectly in QEMU, but we can validate basic functionality"
          echo ""

          # Create verbose log file
          QEMU_LOG_FILE="build/qemu-testing/qemu-test-verbose.log"
          mkdir -p "build/qemu-testing"

          {
            echo "=================================================================="
            echo "  QEMU BOOT TEST - DETAILED LOG"
            echo "=================================================================="
            echo "Started: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo "Build ID: ${{ github.run_id }}"
            echo "Version: ${{ steps.config.outputs.version }}"
            echo ""
          } > "${QEMU_LOG_FILE}"

          log_verbose() {
            echo "$@" | tee -a "${QEMU_LOG_FILE}"
          }

          log_section() {
            {
              echo ""
              echo "-------------------------------------------------------------------"
              echo "  $1"
              echo "-------------------------------------------------------------------"
            } | tee -a "${QEMU_LOG_FILE}"
          }

          VERSION="${{ steps.config.outputs.version }}"
          DEPLOY_DIR="build/pi-gen-work/deploy"

          log_section "STEP 1: Locating Image File"
          log_verbose "Deploy directory: ${DEPLOY_DIR}"
          log_verbose "Searching for .img files..."

          IMAGE_FILE=$(find "${DEPLOY_DIR}" -maxdepth 1 -name "*.img" -type f | head -n 1)

          if [ -z "$IMAGE_FILE" ]; then
            log_verbose "âŒ No image file found for QEMU testing"
            log_verbose "Deploy directory contents:"
            ls -lah "${DEPLOY_DIR}/" | tee -a "${QEMU_LOG_FILE}"
            echo "qemu_test_result=no_image" >> $GITHUB_OUTPUT
            exit 0
          fi

          log_verbose "âœ… Found image: ${IMAGE_FILE}"
          log_verbose "Image size: $(ls -lh "${IMAGE_FILE}" | awk '{print $5}')"
          log_verbose "Image details:"
          file "${IMAGE_FILE}" | tee -a "${QEMU_LOG_FILE}"

          log_section "STEP 2: Installing QEMU"
          log_verbose "Checking QEMU version..."

          if command -v qemu-system-arm &> /dev/null; then
            log_verbose "QEMU already installed:"
            qemu-system-arm --version | head -n 1 | tee -a "${QEMU_LOG_FILE}"
          else
            log_verbose "Installing QEMU ARM system emulator..."
            sudo apt-get update -qq 2>&1 | tee -a "${QEMU_LOG_FILE}"
            sudo apt-get install -y qemu-system-arm 2>&1 | tee -a "${QEMU_LOG_FILE}"
          fi

          log_verbose "âœ… QEMU version:"
          qemu-system-arm --version | tee -a "${QEMU_LOG_FILE}"

          log_section "STEP 3: Creating Test Environment"
          TEST_DIR="build/qemu-testing"
          mkdir -p "${TEST_DIR}"
          cd "${TEST_DIR}"
          log_verbose "âœ… Test directory: $(pwd)"

          log_section "STEP 4: Analyzing Image Partitions"
          log_verbose "Checking image partition table..."
          sudo fdisk -l "${IMAGE_FILE}" 2>&1 | tee -a "${QEMU_LOG_FILE}"

          log_verbose ""
          log_verbose "Checking image partition details with parted..."
          sudo parted "${IMAGE_FILE}" print 2>&1 | tee -a "${QEMU_LOG_FILE}"

          log_section "STEP 5: Setting Up Loop Device"
          LOOP_DEVICE=$(sudo losetup -f)
          log_verbose "Available loop device: ${LOOP_DEVICE}"

          log_verbose "Attaching image to loop device..."
          if sudo losetup -P "${LOOP_DEVICE}" "${IMAGE_FILE}"; then
            log_verbose "âœ… Loop device attached"
          else
            log_verbose "âŒ Failed to attach loop device"
            echo "qemu_test_result=loop_failed" >> $GITHUB_OUTPUT
            exit 0
          fi

          log_verbose "Loop device status:"
          sudo losetup -l | grep "${LOOP_DEVICE}" | tee -a "${QEMU_LOG_FILE}"

          log_verbose ""
          log_verbose "Available partitions:"
          ls -lah "${LOOP_DEVICE}"* 2>&1 | tee -a "${QEMU_LOG_FILE}"

          BOOT_MOUNT="boot_mount"
          mkdir -p "${BOOT_MOUNT}"

          log_section "STEP 6: Mounting Boot Partition"

          # Try different partition naming schemes
          BOOT_PARTITION=""
          if [ -e "${LOOP_DEVICE}p1" ]; then
            BOOT_PARTITION="${LOOP_DEVICE}p1"
          elif [ -e "/dev/mapper/$(basename ${LOOP_DEVICE})p1" ]; then
            BOOT_PARTITION="/dev/mapper/$(basename ${LOOP_DEVICE})p1"
          fi

          if [ -z "$BOOT_PARTITION" ]; then
            log_verbose "âŒ Could not find boot partition"
            sudo losetup -d "${LOOP_DEVICE}" 2>/dev/null || true
            echo "qemu_test_result=no_boot_partition" >> $GITHUB_OUTPUT
            exit 0
          fi

          log_verbose "Boot partition: ${BOOT_PARTITION}"
          log_verbose "Attempting to mount..."

          if sudo mount "${BOOT_PARTITION}" "${BOOT_MOUNT}" 2>&1 | tee -a "${QEMU_LOG_FILE}"; then
            log_verbose "âœ… Boot partition mounted successfully"
          else
            log_verbose "âŒ Failed to mount boot partition"
            sudo losetup -d "${LOOP_DEVICE}" 2>/dev/null || true
            echo "qemu_test_result=mount_failed" >> $GITHUB_OUTPUT
            exit 0
          fi

          log_section "STEP 7: Examining Boot Partition Contents"
          log_verbose "Boot partition files:"
          ls -lah "${BOOT_MOUNT}/" | tee -a "${QEMU_LOG_FILE}"

          log_verbose ""
          log_verbose "Kernel files available:"
          ls -lh "${BOOT_MOUNT}"/kernel*.img 2>&1 | tee -a "${QEMU_LOG_FILE}"

          log_verbose ""
          log_verbose "Device tree files:"
          ls -lh "${BOOT_MOUNT}"/*.dtb 2>&1 | tee -a "${QEMU_LOG_FILE}"

          log_verbose ""
          log_verbose "Config.txt contents (first 30 lines):"
          head -n 30 "${BOOT_MOUNT}/config.txt" 2>&1 | tee -a "${QEMU_LOG_FILE}"

          log_section "STEP 8: Extracting Kernel"
          KERNEL_FOUND=false

          if [ -f "${BOOT_MOUNT}/kernel8.img" ]; then
            log_verbose "Found kernel8.img (64-bit)"
            sudo cp "${BOOT_MOUNT}/kernel8.img" "kernel.img"
            KERNEL_TYPE="kernel8"
            KERNEL_FOUND=true
          elif [ -f "${BOOT_MOUNT}/kernel7l.img" ]; then
            log_verbose "Found kernel7l.img (32-bit LPAE)"
            sudo cp "${BOOT_MOUNT}/kernel7l.img" "kernel.img"
            KERNEL_TYPE="kernel7l"
            KERNEL_FOUND=true
          elif [ -f "${BOOT_MOUNT}/kernel7.img" ]; then
            log_verbose "Found kernel7.img (32-bit)"
            sudo cp "${BOOT_MOUNT}/kernel7.img" "kernel.img"
            KERNEL_TYPE="kernel7"
            KERNEL_FOUND=true
          elif [ -f "${BOOT_MOUNT}/kernel.img" ]; then
            log_verbose "Found kernel.img (original Pi)"
            sudo cp "${BOOT_MOUNT}/kernel.img" "kernel.img"
            KERNEL_TYPE="kernel"
            KERNEL_FOUND=true
          fi

          if [ "$KERNEL_FOUND" = false ]; then
            log_verbose "âŒ No kernel found in boot partition"
            sudo umount "${BOOT_MOUNT}" 2>/dev/null || true
            sudo losetup -d "${LOOP_DEVICE}" 2>/dev/null || true
            echo "qemu_test_result=no_kernel" >> $GITHUB_OUTPUT
            exit 0
          fi

          log_verbose "âœ… Extracted ${KERNEL_TYPE}.img"
          log_verbose "Kernel file size: $(ls -lh kernel.img | awk '{print $5}')"
          log_verbose "Kernel file type:"
          file kernel.img | tee -a "${QEMU_LOG_FILE}"

          log_section "STEP 9: Extracting Device Tree (if available)"
          DTB_FOUND=false

          for dtb_file in "bcm2711-rpi-4-b.dtb" "bcm2710-rpi-3-b-plus.dtb" "bcm2710-rpi-3-b.dtb" "bcm2709-rpi-2-b.dtb"; do
            if [ -f "${BOOT_MOUNT}/${dtb_file}" ]; then
              log_verbose "Found device tree: ${dtb_file}"
              sudo cp "${BOOT_MOUNT}/${dtb_file}" "device-tree.dtb"
              DTB_FOUND=true
              log_verbose "âœ… Extracted device tree"
              break
            fi
          done

          if [ "$DTB_FOUND" = false ]; then
            log_verbose "âš ï¸  No device tree found (may not be critical)"
          fi

          log_section "STEP 10: Cleaning Up Mounts"
          log_verbose "Unmounting boot partition..."
          sudo umount "${BOOT_MOUNT}" 2>&1 | tee -a "${QEMU_LOG_FILE}" || true

          log_verbose "Detaching loop device..."
          sudo losetup -d "${LOOP_DEVICE}" 2>&1 | tee -a "${QEMU_LOG_FILE}" || true

          log_verbose "Fixing kernel permissions..."
          sudo chmod 644 kernel.img 2>&1 | tee -a "${QEMU_LOG_FILE}" || true

          log_verbose "âœ… Cleanup complete"

          log_section "STEP 11: Preparing QEMU Configuration"
          log_verbose "QEMU machine type: versatilepb"
          log_verbose "QEMU CPU: arm1176"
          log_verbose "QEMU memory: 256MB"
          log_verbose "Kernel: kernel.img"
          log_verbose "Drive: ${IMAGE_FILE}"
          log_verbose "Boot timeout: 30 seconds"

          log_verbose ""
          log_verbose "Full QEMU command:"
          log_verbose "qemu-system-arm \\"
          log_verbose "  -M versatilepb \\"
          log_verbose "  -cpu arm1176 \\"
          log_verbose "  -m 256 \\"
          log_verbose "  -kernel kernel.img \\"
          log_verbose "  -drive file=${IMAGE_FILE},format=raw \\"
          log_verbose "  -append 'root=/dev/sda2 rootfstype=ext4 rw console=ttyAMA0' \\"
          log_verbose "  -nographic \\"
          log_verbose "  -serial stdio \\"
          log_verbose "  -no-reboot"

          log_section "STEP 12: Running QEMU Boot Test"
          log_verbose "Starting QEMU (30 second timeout)..."
          log_verbose "NOTE: Raspberry Pi images don't boot perfectly in QEMU"
          log_verbose "We're looking for any signs of kernel activity"
          log_verbose ""

          BOOT_LOG="boot-full.log"
          BOOT_ERRORS="boot-errors.log"

          # Capture full output and errors separately
          timeout 30 qemu-system-arm \
            -M versatilepb \
            -cpu arm1176 \
            -m 256 \
            -kernel kernel.img \
            -drive "file=${IMAGE_FILE},format=raw" \
            -append "root=/dev/sda2 rootfstype=ext4 rw console=ttyAMA0" \
            -nographic \
            -serial stdio \
            -no-reboot > "${BOOT_LOG}" 2> "${BOOT_ERRORS}" || QEMU_EXIT_CODE=$?

          log_verbose "QEMU process completed with exit code: ${QEMU_EXIT_CODE:-0}"

          log_section "STEP 13: Analyzing Boot Output"

          log_verbose "Boot log size: $(wc -l < "${BOOT_LOG}") lines"
          log_verbose "Error log size: $(wc -l < "${BOOT_ERRORS}") lines"
          log_verbose ""

          log_verbose "=== BOOT LOG (first 100 lines) ==="
          head -n 100 "${BOOT_LOG}" | tee -a "${QEMU_LOG_FILE}"

          log_verbose ""
          log_verbose "=== BOOT LOG (last 50 lines) ==="
          tail -n 50 "${BOOT_LOG}" | tee -a "${QEMU_LOG_FILE}"

          log_verbose ""
          log_verbose "=== ERROR LOG (all lines) ==="
          cat "${BOOT_ERRORS}" | tee -a "${QEMU_LOG_FILE}"

          log_section "STEP 14: Checking for Boot Indicators"

          # Initialize counters
          BOOT_INDICATORS=0

          # Check for various boot-related strings
          if grep -qi "booting\|starting kernel" "${BOOT_LOG}"; then
            log_verbose "âœ… Found: Kernel boot messages"
            ((BOOT_INDICATORS++))
          else
            log_verbose "âŒ Not found: Kernel boot messages"
          fi

          if grep -qi "linux version" "${BOOT_LOG}"; then
            log_verbose "âœ… Found: Linux version string"
            ((BOOT_INDICATORS++))
          else
            log_verbose "âŒ Not found: Linux version string"
          fi

          if grep -qi "kernel command line" "${BOOT_LOG}"; then
            log_verbose "âœ… Found: Kernel command line"
            ((BOOT_INDICATORS++))
          else
            log_verbose "âŒ Not found: Kernel command line"
          fi

          if grep -qi "mounting\|mount.*root" "${BOOT_LOG}"; then
            log_verbose "âœ… Found: Filesystem mounting"
            ((BOOT_INDICATORS++))
          else
            log_verbose "âŒ Not found: Filesystem mounting"
          fi

          if grep -qi "systemd\|init" "${BOOT_LOG}"; then
            log_verbose "âœ… Found: Init system"
            ((BOOT_INDICATORS++))
          else
            log_verbose "âŒ Not found: Init system"
          fi

          if grep -qi "panic\|fatal\|oops" "${BOOT_LOG}"; then
            log_verbose "âš ï¸  Found: Kernel panic or fatal error"
          fi

          log_verbose ""
          log_verbose "Boot indicators found: ${BOOT_INDICATORS}/5"

          log_section "STEP 15: Determining Test Result"

          if [ ${BOOT_INDICATORS} -ge 3 ]; then
            log_verbose "âœ… QEMU boot test: PASSED (${BOOT_INDICATORS}/5 indicators)"
            log_verbose "The kernel showed significant boot activity"
            echo "qemu_test_result=passed" >> $GITHUB_OUTPUT
          elif [ ${BOOT_INDICATORS} -ge 1 ]; then
            log_verbose "âš ï¸  QEMU boot test: PARTIAL (${BOOT_INDICATORS}/5 indicators)"
            log_verbose "The kernel showed some boot activity"
            echo "qemu_test_result=partial" >> $GITHUB_OUTPUT
          else
            log_verbose "âŒ QEMU boot test: INCONCLUSIVE (${BOOT_INDICATORS}/5 indicators)"
            log_verbose "No clear boot indicators found"
            echo "qemu_test_result=inconclusive" >> $GITHUB_OUTPUT
          fi

          log_section "STEP 16: Finalizing Test"

          log_verbose "Copying logs to test directory..."
          cp "${BOOT_LOG}" "boot-attempt.log" || true

          log_verbose ""
          log_verbose "Test artifacts created:"
          ls -lh boot-*.log kernel.img *.dtb 2>&1 | tee -a "${QEMU_LOG_FILE}"

          {
            echo ""
            echo "=================================================================="
            echo "  QEMU BOOT TEST COMPLETE"
            echo "=================================================================="
            echo "Completed: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo "Result: ${BOOT_INDICATORS}/5 boot indicators found"
            echo "Full logs available in: ${QEMU_LOG_FILE}"
            echo "=================================================================="
          } | tee -a "${QEMU_LOG_FILE}"

          log_verbose "âœ… QEMU test complete - detailed log saved"

          set +x  # Disable verbose bash debugging

      - name: Generate test summary report
        if: success()
        run: |
          echo "ðŸ“Š Generating comprehensive test summary..."

          VERSION="${{ steps.config.outputs.version }}"
          BUILD_DATE=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
          COMMIT_SHA="${{ github.sha }}"
          BUILD_ID="${{ github.run_id }}"
          VALIDATION_STATUS="${{ steps.validation.outputs.validation_status }}"
          QEMU_TEST_RESULT="${{ steps.qemu_test.outputs.qemu_test_result }}"

          REPORT_FILE="build/pi-gen-work/deploy/TESTING_REPORT_v${VERSION}.md"

          # Make script executable
          chmod +x scripts/generate-test-report.sh

          # Generate report
          ./scripts/generate-test-report.sh \
            "${VERSION}" \
            "${BUILD_DATE}" \
            "${COMMIT_SHA}" \
            "${BUILD_ID}" \
            "${VALIDATION_STATUS}" \
            "${QEMU_TEST_RESULT}" \
            "${REPORT_FILE}"

          echo "report_file=${REPORT_FILE}" >> $GITHUB_OUTPUT

          # Display summary
          echo ""
          echo "ðŸ“„ Test Summary Report Preview:"
          echo "================================"
          head -n 30 "${REPORT_FILE}"
          echo "================================"
          echo "(Full report will be included in release assets)"

      - name: Prepare release assets
        id: assets
        run: |
          echo "ðŸ“¦ Preparing release assets..."

          VERSION="${{ steps.config.outputs.version }}"
          DEPLOY_DIR="build/pi-gen-work/deploy"

          # Verify deploy directory exists (should be caught in build step, but double-check)
          if [ ! -d "${DEPLOY_DIR}" ]; then
            echo "âŒ Error: Deploy directory does not exist at ${DEPLOY_DIR}"
            echo "The build may have failed. Check previous step logs."
            exit 1
          fi

          # Fix permissions on deploy directory (built with sudo)
          sudo chown -R runner:runner "${DEPLOY_DIR}" || {
            echo "âŒ Failed to change ownership of deploy directory"
            exit 1
          }

          # Find the built image using proper quoting and find command
          IMAGE_FILE=$(find "${DEPLOY_DIR}" -maxdepth 1 -name "*.img" -type f | head -n 1)

          if [ -z "$IMAGE_FILE" ]; then
            echo "âŒ Error: No image file found!"
            echo "Contents of deploy directory:"
            ls -la "${DEPLOY_DIR}/" || echo "Directory is empty or inaccessible"
            exit 1
          fi

          echo "Found image: $IMAGE_FILE"

          # Create versioned filename
          VERSIONED_IMAGE="RaspberryPi_HDMI_Tester_v${VERSION}.img"
          VERSIONED_ARCHIVE="RaspberryPi_HDMI_Tester_v${VERSION}.img.gz"
          CHECKSUM_FILE="RaspberryPi_HDMI_Tester_v${VERSION}.sha256"

          # Copy and rename image
          cp "$IMAGE_FILE" "${DEPLOY_DIR}/${VERSIONED_IMAGE}"

          # Compress image using pigz (parallel gzip) for maximum speed
          echo "ðŸ—œï¸  Compressing image with pigz (parallel gzip)..."
          echo "   This is significantly faster than zip (~2 min vs ~10 min)"

          COMPRESSION_START=$(date +%s)
          (cd "${DEPLOY_DIR}" && pigz -9 -k "${VERSIONED_IMAGE}")
          COMPRESSION_END=$(date +%s)
          COMPRESSION_TIME=$((COMPRESSION_END - COMPRESSION_START))

          echo "âœ… Compression complete in ${COMPRESSION_TIME} seconds"

          # Generate SHA256 checksums and verification instructions
          echo "ðŸ” Generating checksums and verification instructions..."
          chmod +x "${GITHUB_WORKSPACE}/scripts/generate-checksums.sh"

          # Pass absolute path to ensure script can find directory
          DEPLOY_DIR_ABS="$(cd "${DEPLOY_DIR}" && pwd)"
          "${GITHUB_WORKSPACE}/scripts/generate-checksums.sh" "${VERSION}" "${DEPLOY_DIR_ABS}"

          # Get file sizes (from deploy directory)
          IMAGE_SIZE=$(ls -lh "${DEPLOY_DIR}/${VERSIONED_IMAGE}" | awk '{print $5}')
          ARCHIVE_SIZE=$(ls -lh "${DEPLOY_DIR}/${VERSIONED_ARCHIVE}" | awk '{print $5}')

          TESTING_REPORT="TESTING_REPORT_v${VERSION}.md"
          VERIFY_FILE="VERIFY_DOWNLOAD_v${VERSION}.txt"
          CHECKSUM_SHA256="RaspberryPi_HDMI_Tester_v${VERSION}.sha256"
          CHECKSUM_SHA1="RaspberryPi_HDMI_Tester_v${VERSION}.sha1"
          CHECKSUM_MD5="RaspberryPi_HDMI_Tester_v${VERSION}.md5"
          CHECKSUM_BLAKE2="RaspberryPi_HDMI_Tester_v${VERSION}.blake2"

          echo "image_size=$IMAGE_SIZE" >> $GITHUB_OUTPUT
          echo "archive_size=$ARCHIVE_SIZE" >> $GITHUB_OUTPUT
          echo "archive_path=${DEPLOY_DIR}/${VERSIONED_ARCHIVE}" >> $GITHUB_OUTPUT
          echo "checksum_sha256=${DEPLOY_DIR}/${CHECKSUM_SHA256}" >> $GITHUB_OUTPUT
          echo "checksum_sha1=${DEPLOY_DIR}/${CHECKSUM_SHA1}" >> $GITHUB_OUTPUT
          echo "checksum_md5=${DEPLOY_DIR}/${CHECKSUM_MD5}" >> $GITHUB_OUTPUT
          echo "checksum_blake2=${DEPLOY_DIR}/${CHECKSUM_BLAKE2}" >> $GITHUB_OUTPUT
          echo "testing_report=${DEPLOY_DIR}/${TESTING_REPORT}" >> $GITHUB_OUTPUT
          echo "verify_file=${DEPLOY_DIR}/${VERIFY_FILE}" >> $GITHUB_OUTPUT

          echo "âœ… Assets prepared"
          echo "   Image size: $IMAGE_SIZE"
          echo "   Compressed: $ARCHIVE_SIZE (gzip format)"
          echo "   Compression time: ${COMPRESSION_TIME}s"
          echo "   Checksums: SHA256, SHA1, MD5, BLAKE2"
          if [ -f "${DEPLOY_DIR}/${TESTING_REPORT}" ]; then
            echo "   Testing report: ${TESTING_REPORT}"
          fi
          if [ -f "${DEPLOY_DIR}/${VERIFY_FILE}" ]; then
            echo "   Verification instructions: ${VERIFY_FILE}"
          fi

      - name: Generate release notes
        id: notes
        run: |
          VERSION="${{ steps.config.outputs.version }}"
          BUILD_DATE=$(date -u +"%Y-%m-%d %H:%M:%S UTC")

          # Extract data from config
          FEATURES=$(jq -r '.release_notes.features[] | "- " + .' .github/release-config.json)
          COMPATIBILITY=$(jq -r '.release_notes.compatibility[] | "- " + .' .github/release-config.json)
          KNOWN_ISSUES=$(jq -r '.release_notes.known_issues[] | "- " + .' .github/release-config.json)
          BASE_OS=$(jq -r '.build.base_os' .github/release-config.json)
          BUILD_SYSTEM=$(jq -r '.build.build_system' .github/release-config.json)

          # Generate release notes
          cat > release_notes.md << EOF
          # Raspberry Pi HDMI Tester v${{ steps.config.outputs.version }}

          ## ðŸ“¦ Release: ${{ steps.config.outputs.name }}

          **Build Date:** ${BUILD_DATE}
          **Commit:** ${{ github.sha }}

          ---

          ## âœ¨ Features

          ${FEATURES}

          ## ðŸ”§ Compatibility

          Tested and compatible with:
          ${COMPATIBILITY}

          ## âš ï¸ Known Issues

          ${KNOWN_ISSUES}

          ---

          ## ðŸ“¥ Installation

          ### Quick Start (Windows 11)

          1. **Download** \`RaspberryPi_HDMI_Tester_v${{ steps.config.outputs.version }}.img.gz\`
          2. **Extract** the \`.img\` file from the gzip archive
             - Windows: Use [7-Zip](https://www.7-zip.org/) or extract via Raspberry Pi Imager directly
             - macOS/Linux: \`gunzip RaspberryPi_HDMI_Tester_v${{ steps.config.outputs.version }}.img.gz\`
          3. **Flash** to SD card using [Raspberry Pi Imager](https://www.raspberrypi.com/software/)
             - Note: Raspberry Pi Imager can read .gz files directly - no need to extract!
          4. **Insert** SD card into Raspberry Pi
          5. **Connect** HDMI to display
          6. **Power on** - it will boot automatically!

          ### Verification

          Verify the download integrity:
          \`\`\`bash
          sha256sum -c RaspberryPi_HDMI_Tester_v${{ steps.config.outputs.version }}.sha256
          \`\`\`

          ### Full Documentation

          - ðŸ“– [Building Guide](https://github.com/benpaddlejones/Raspberry_HDMI_Tester/blob/main/docs/BUILDING.md)
          - ðŸ’¾ [Flashing Guide](https://github.com/benpaddlejones/Raspberry_HDMI_Tester/blob/main/docs/FLASHING.md)
          - ðŸŽ¨ [Customization Guide](https://github.com/benpaddlejones/Raspberry_HDMI_Tester/blob/main/docs/CUSTOMIZATION.md)
          - ðŸ”§ [Troubleshooting Guide](https://github.com/benpaddlejones/Raspberry_HDMI_Tester/blob/main/docs/TROUBLESHOOTING.md)

          ---

          ## ðŸ“Š Build Information

          - **Base OS:** ${BASE_OS}
          - **Build System:** ${BUILD_SYSTEM}
          - **Image Size:** ${{ steps.assets.outputs.image_size }}
          - **Compressed Size:** ${{ steps.assets.outputs.archive_size }} (gzip format)
          - **Compression:** Parallel gzip (pigz) for faster downloads

          ---

          ## ðŸ› Issues & Support

          Found a bug? Have a question?
          - [Report an Issue](https://github.com/benpaddlejones/Raspberry_HDMI_Tester/issues)
          - [View Documentation](https://github.com/benpaddlejones/Raspberry_HDMI_Tester#readme)
          EOF

          cat release_notes.md

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.config.outputs.tag }}
          name: "v${{ steps.config.outputs.version }} - ${{ steps.config.outputs.name }}"
          body_path: release_notes.md
          target_commitish: ${{ github.ref_name }}
          files: |
            ${{ steps.assets.outputs.archive_path }}
            ${{ steps.assets.outputs.checksum_sha256 }}
            ${{ steps.assets.outputs.checksum_sha1 }}
            ${{ steps.assets.outputs.checksum_md5 }}
            ${{ steps.assets.outputs.checksum_blake2 }}
            ${{ steps.assets.outputs.testing_report }}
            ${{ steps.assets.outputs.verify_file }}
          draft: false
          prerelease: ${{ steps.config.outputs.prerelease }}
          make_latest: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update README with release link
        run: |
          VERSION="${{ steps.config.outputs.version }}"
          TAG="${{ steps.config.outputs.tag }}"

          # Create download section content
          cat > download_section.md << 'DOWNLOADEOF'

          ## ðŸ“¥ Download

          [![Latest Release](https://img.shields.io/github/v/release/benpaddlejones/Raspberry_HDMI_Tester?label=Latest%20Release&style=for-the-badge)](https://github.com/benpaddlejones/Raspberry_HDMI_Tester/releases/latest)
          [![Downloads](https://img.shields.io/github/downloads/benpaddlejones/Raspberry_HDMI_Tester/total?style=for-the-badge)](https://github.com/benpaddlejones/Raspberry_HDMI_Tester/releases)

          **Latest Version:** [VERSION_TAG](https://github.com/benpaddlejones/Raspberry_HDMI_Tester/releases/tag/VERSION_TAG)

          Download the pre-built image and flash to your SD card.
          DOWNLOADEOF

          # Replace placeholders
          sed -i "s/VERSION_TAG/$TAG/g" download_section.md
          sed -i "s/VERSION_NUM/v$VERSION/g" download_section.md

          # Replace Download section (remove old, add new)
          if grep -q "## ðŸ“¥ Download" README.md; then
            # Section exists - replace it
            echo "Updating existing Download section..."

            # Find start and end of Download section
            START_LINE=$(grep -n "## ðŸ“¥ Download" README.md | head -n1 | cut -d: -f1)
            # Find next ## heading or end of file
            NEXT_SECTION=$(tail -n +$((START_LINE + 1)) README.md | grep -n "^## " | head -n1 | cut -d: -f1)

            if [ -n "$NEXT_SECTION" ]; then
              END_LINE=$((START_LINE + NEXT_SECTION - 1))
              # Delete old section
              sed -i "${START_LINE},${END_LINE}d" README.md
            else
              # Download section is at end of file
              sed -i "${START_LINE},\$d" README.md
            fi

            # Insert new section at the same position
            sed -i "${START_LINE}r download_section.md" README.md
            echo "âœ… Download section updated"
          else
            # Section doesn't exist - add after Project Overview
            sed -i '/## Project Overview/r download_section.md' README.md
            echo "âœ… Download section added to README"
          fi

          rm -f download_section.md

      - name: Commit README changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          git add README.md

          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "docs: Update README with release v${{ steps.config.outputs.version }} links [skip ci]"

            # Pull latest changes before pushing (in case logs were committed)
            git pull --rebase origin ${GITHUB_REF_NAME} || {
              echo "âš ï¸ Rebase failed, trying merge..."
              git pull origin ${GITHUB_REF_NAME}
            }

            git push || {
              echo "âŒ Failed to push README updates"
              exit 1
            }

            echo "âœ… README updates pushed successfully"
          fi

      - name: Push failed build logs
        if: failure()
        run: |
          # If build failed, push the committed logs now
          echo "ðŸ“ Pushing failed build logs to repository..."

          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          # Check if there are commits to push
          if git log origin/${GITHUB_REF_NAME}..HEAD --oneline | grep -q .; then
            echo "Found commits to push..."

            git pull --rebase origin ${GITHUB_REF_NAME} || {
              echo "âš ï¸ Rebase failed, trying merge..."
              git pull origin ${GITHUB_REF_NAME}
            }

            git push || {
              echo "âŒ CRITICAL: Failed to push failed build logs"
              echo "Manual intervention required to push logs"
              exit 1
            }

            echo "âœ… Failed build logs pushed successfully"
          else
            echo "No commits to push (logs may already be pushed)"
          fi

      - name: Build summary
        if: always()
        run: |
          BUILD_EXIT_CODE="${{ env.BUILD_EXIT_CODE }}"
          BUILD_TIMESTAMP="${{ env.BUILD_TIMESTAMP }}"
          VALIDATION_STATUS="${{ steps.validation.outputs.validation_status }}"
          QEMU_TEST_RESULT="${{ steps.qemu_test.outputs.qemu_test_result }}"

          if [ "${BUILD_EXIT_CODE}" = "0" ]; then
            echo "## ðŸŽ‰ Release Build Complete!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Version:** v${{ steps.config.outputs.version }}" >> $GITHUB_STEP_SUMMARY
            echo "- Image (compressed): ${{ steps.assets.outputs.archive_size }} (.gz format)" >> $GITHUB_STEP_SUMMARY
            echo "- Image (uncompressed): ${{ steps.assets.outputs.image_size }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            echo "### âœ… Validation Results:" >> $GITHUB_STEP_SUMMARY
            echo "- **Image Validation:** ${VALIDATION_STATUS:-unknown}" >> $GITHUB_STEP_SUMMARY

            # Enhanced QEMU result display
            case "${QEMU_TEST_RESULT:-not_run}" in
              passed)
                echo "- **QEMU Boot Test:** âœ… Passed (kernel showed significant boot activity)" >> $GITHUB_STEP_SUMMARY
                ;;
              partial)
                echo "- **QEMU Boot Test:** âš ï¸ Partial (kernel showed some boot activity)" >> $GITHUB_STEP_SUMMARY
                ;;
              inconclusive)
                echo "- **QEMU Boot Test:** â“ Inconclusive (no clear boot indicators)" >> $GITHUB_STEP_SUMMARY
                ;;
              no_image|no_kernel|no_boot_partition|loop_failed|mount_failed)
                echo "- **QEMU Boot Test:** âš ï¸ Skipped (${QEMU_TEST_RESULT})" >> $GITHUB_STEP_SUMMARY
                ;;
              *)
                echo "- **QEMU Boot Test:** ${QEMU_TEST_RESULT:-not run}" >> $GITHUB_STEP_SUMMARY
                ;;
            esac

            echo "" >> $GITHUB_STEP_SUMMARY

            echo "### ðŸ”— Release URL:" >> $GITHUB_STEP_SUMMARY
            echo "[View Release](https://github.com/benpaddlejones/Raspberry_HDMI_Tester/releases/tag/${{ steps.config.outputs.tag }})" >> $GITHUB_STEP_SUMMARY
          else
            echo "## âŒ Build Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Build Timestamp:** ${BUILD_TIMESTAMP}" >> $GITHUB_STEP_SUMMARY
            echo "**Exit Code:** ${BUILD_EXIT_CODE}" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“ Build & Test Logs:" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Log (Artifact):** Available in workflow artifacts (retained for 90 days)" >> $GITHUB_STEP_SUMMARY
          echo "- **QEMU Test Log (Artifact):** Detailed QEMU boot test logs with step-by-step analysis" >> $GITHUB_STEP_SUMMARY
          echo "- **Committed Log:** Check \`logs/\` directory in repository" >> $GITHUB_STEP_SUMMARY

          if [ -f "build/pi-gen-work/build-detailed.log" ]; then
            LOG_SIZE=$(stat -f%z "build/pi-gen-work/build-detailed.log" 2>/dev/null || stat -c%s "build/pi-gen-work/build-detailed.log")
            LOG_SIZE_MB=$(( LOG_SIZE / 1048576 ))
            echo "- **Build Log Size:** ${LOG_SIZE_MB}MB" >> $GITHUB_STEP_SUMMARY
          fi

          if [ -f "build/qemu-testing/qemu-test-verbose.log" ]; then
            QEMU_LOG_SIZE=$(stat -f%z "build/qemu-testing/qemu-test-verbose.log" 2>/dev/null || stat -c%s "build/qemu-testing/qemu-test-verbose.log")
            QEMU_LOG_SIZE_KB=$(( QEMU_LOG_SIZE / 1024 ))
            echo "- **QEMU Test Log Size:** ${QEMU_LOG_SIZE_KB}KB" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ’¡ **Tip:** Download QEMU test logs artifact for detailed step-by-step boot analysis" >> $GITHUB_STEP_SUMMARY
          fi
